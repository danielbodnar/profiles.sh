---
import Base from "../../layouts/Base.astro";
import ProfileHeader from "../../components/ProfileHeader.astro";
import RadarChart from "../../components/RadarChart.astro";
import AggregateChart from "../../components/AggregateChart.astro";
import StarInterestTile from "../../components/StarInterestTile.astro";
import ColorLegend from "../../components/ColorLegend.astro";
import PersonaCard from "../../components/PersonaCard.astro";
import PersonaModal from "../../components/PersonaModal.astro";
import ProjectCard from "../../components/ProjectCard.astro";
import ProjectModal from "../../components/ProjectModal.astro";
import LoadingState from "../../components/LoadingState.astro";
import { PERSONA_COLORS } from "../../styles/tokens";
import { processUsername } from "../../lib/queue-consumer";
import { parseProfileParams } from "../../lib/query-params";

const { username } = Astro.params;

if (!username) {
  return Astro.redirect("/");
}

// Parse query params for featuring & refresh
const queryParams = parseProfileParams(Astro.url);

// Access Cloudflare bindings directly (Workers can't self-fetch)
let profileData: any = null;
let aggregates: any[] = [];
let isComputing = false;
let errorMessage = "";

try {
  const env = Astro.locals.runtime.env as Env;
  const lowerUsername = username.toLowerCase();

  // Check D1 for existing profile
  let profile = await env.DB.prepare('SELECT * FROM profiles WHERE username = ?')
    .bind(lowerUsername).first();

  // Force re-compute if ?refresh=true or no profile exists
  if (!profile || queryParams.refresh) {
    try {
      await processUsername(lowerUsername, env);
      profile = await env.DB.prepare('SELECT * FROM profiles WHERE username = ?')
        .bind(lowerUsername).first();
    } catch (err: any) {
      if (err?.message?.includes('not found')) {
        errorMessage = `User "${username}" not found on GitHub.`;
      } else if (err?.message?.includes('rate limit')) {
        errorMessage = "GitHub API rate limit exceeded. Please try again later.";
      } else {
        errorMessage = "Failed to compute profile. Please try again.";
      }
    }
  }

  if (profile && !errorMessage) {
    // Fetch all related data from D1 (including aggregates)
    const [personasResult, projectsResult, radarResult, interestsResult, aggregatesResult] = await Promise.all([
      env.DB.prepare('SELECT * FROM personas WHERE username = ? ORDER BY sort_order ASC').bind(lowerUsername).all(),
      env.DB.prepare('SELECT * FROM projects WHERE username = ? ORDER BY sort_order ASC').bind(lowerUsername).all(),
      env.DB.prepare('SELECT * FROM radar_axes WHERE username = ? ORDER BY sort_order ASC').bind(lowerUsername).all(),
      env.DB.prepare('SELECT * FROM star_interests WHERE username = ? ORDER BY sort_order ASC').bind(lowerUsername).all(),
      env.DB.prepare('SELECT * FROM user_aggregates WHERE username = ? ORDER BY agg_type ASC, sort_order ASC').bind(lowerUsername).all(),
    ]);

    // Parse JSON columns
    const personas = personasResult.results.map((p: any) => ({
      ...p,
      stats: typeof p.stats === 'string' ? JSON.parse(p.stats) : p.stats,
      stack: typeof p.stack === 'string' ? JSON.parse(p.stack) : p.stack,
      details: typeof p.details === 'string' ? JSON.parse(p.details) : p.details,
      starred_repos: typeof p.starred_repos === 'string' ? JSON.parse(p.starred_repos) : p.starred_repos,
      employers: typeof p.employers === 'string' ? JSON.parse(p.employers) : p.employers,
      links: typeof p.links === 'string' ? JSON.parse(p.links) : p.links,
    }));

    const projects = projectsResult.results.map((p: any) => ({
      ...p,
      tech: typeof p.tech === 'string' ? JSON.parse(p.tech) : p.tech,
      persona_map: typeof p.persona_map === 'string' ? JSON.parse(p.persona_map) : p.persona_map,
    }));

    aggregates = aggregatesResult.results as any[];

    profileData = {
      profile: {
        ...profile,
        raw_profile: typeof profile.raw_profile === 'string' ? JSON.parse(profile.raw_profile as string) : profile.raw_profile,
      },
      personas,
      projects,
      radar: radarResult.results,
      interests: interestsResult.results,
    };
  }
} catch (e: any) {
  if (!errorMessage) {
    errorMessage = "Failed to load profile. Please try again.";
  }
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

function buildRadarAxes(profile: any) {
  if (!profile?.radar) return [];
  return profile.radar.map((r: any) => ({
    label: r.label,
    value: r.value,
    color: r.color,
  }));
}

function buildSubtitle(profile: any): string {
  if (!profile?.personas) return "";
  return profile.personas
    .slice(0, 4)
    .map((p: any) => {
      let t = p.title || "";
      return t.replace(/^(Principal|Staff|Crazy)\s+/, "");
    })
    .join(" \u00B7 ");
}

function buildMeta(profile: any): string {
  const parts: string[] = [];
  if (profile?.profile?.location) parts.push(profile.profile.location);
  if (profile?.profile?.username) parts.push(`github.com/${profile.profile.username}`);
  return parts.join(" \u00B7 ");
}

function buildPersonaRefs(profile: any): { id: string; shortTitle: string; accent: string }[] {
  if (!profile?.personas) return [];
  return profile.personas.map((p: any) => ({
    id: p.persona_id,
    shortTitle: (p.title || "").replace(/^(Principal|Staff|Crazy)\s+/, ""),
    accent: p.accent_color || PERSONA_COLORS[p.persona_id]?.accent || "#888",
  }));
}

function formatCount(n: number): string {
  if (n >= 1000) return `${(n / 1000).toFixed(1)}k`;
  return String(n);
}

// GitHub language colors (top languages)
const LANG_COLORS: Record<string, string> = {
  rust: "#dea584",
  typescript: "#3178c6",
  javascript: "#f1e05a",
  python: "#3572a5",
  go: "#00add8",
  java: "#b07219",
  "c++": "#f34b7d",
  c: "#555555",
  ruby: "#701516",
  swift: "#f05138",
  kotlin: "#a97bff",
  lua: "#000080",
  shell: "#89e051",
  nushell: "#3aa675",
  zig: "#ec915c",
  haskell: "#5e5086",
  nix: "#7e7eff",
  vue: "#41b883",
  svelte: "#ff3e00",
  astro: "#ff5d01",
  html: "#e34c26",
  css: "#563d7c",
  scss: "#c6538c",
};

// ---------------------------------------------------------------------------
// Computed values
// ---------------------------------------------------------------------------

const radarAxes = profileData ? buildRadarAxes(profileData) : [];
const subtitle = profileData ? buildSubtitle(profileData) : "";
const meta = profileData ? buildMeta(profileData) : "";
const personaRefs = profileData ? buildPersonaRefs(profileData) : [];

// Compute stats for badges
const reposAnalyzed = profileData?.projects?.length ?? 0;
const starsAnalyzed = aggregates
  .filter((a: any) => a.agg_type === "language")
  .reduce((sum: number, a: any) => sum + (a.from_starred || 0), 0);
const memberSince = profileData?.profile?.created_at
  ? new Date(profileData.profile.created_at).getFullYear()
  : null;

const badges = profileData ? [
  { label: "repos analyzed", value: String(reposAnalyzed) },
  ...(starsAnalyzed > 0 ? [{ label: "stars analyzed", value: formatCount(starsAnalyzed) }] : []),
  ...(profileData.profile?.followers ? [{ label: "followers", value: formatCount(profileData.profile.followers) }] : []),
  ...(memberSince ? [{ label: "member since", value: String(memberSince) }] : []),
] : [];

// Group aggregates by type
const aggByType: Record<string, any[]> = {};
for (const a of aggregates) {
  const t = (a as any).agg_type;
  if (!aggByType[t]) aggByType[t] = [];
  aggByType[t].push(a);
}

// Top languages and topics for pills
const topLanguages = (aggByType["language"] || []).slice(0, 5).map((a: any) => ({
  name: a.item,
  color: LANG_COLORS[a.item.toLowerCase()] || undefined,
}));

const topTopics = (aggByType["topic"] || []).slice(0, 5).map((a: any) => ({
  name: a.item,
}));

// Aggregate chart data
const chartSections = [
  { key: "language", title: "Languages" },
  { key: "framework", title: "Frameworks" },
  { key: "topic", title: "Topics" },
  { key: "tooling", title: "Tooling" },
].filter((s) => (aggByType[s.key] || []).length > 0);

// Apply query param featuring to projects
let displayProjects = profileData?.projects || [];
if (queryParams.featuredRepos.length > 0) {
  const featured = new Set(queryParams.featuredRepos);
  displayProjects = [
    ...displayProjects.filter((p: any) => featured.has(p.name?.toLowerCase())),
    ...displayProjects.filter((p: any) => !featured.has(p.name?.toLowerCase())),
  ];
}

// Apply query param featuring to star interests
const featuredStarsSet = new Set(queryParams.featuredStars);
const featuredTopicsSet = new Set(queryParams.featuredTopics);
const featuredOrgsSet = new Set(queryParams.featuredOrgs);

const pageTitle = profileData?.profile?.display_name
  ? `${profileData.profile.display_name} — profiles.sh`
  : `${username} — profiles.sh`;
const pageDesc = profileData?.profile?.display_name
  ? `Professional persona cards for ${profileData.profile.display_name}`
  : `profiles.sh for ${username}`;
---
<Base title={pageTitle} description={pageDesc}>
  {isComputing && (
    <LoadingState username={username} />
  )}

  {errorMessage && (
    <main class="error-page">
      <div class="error-content">
        <div class="label">profiles.sh</div>
        <h1 class="error-title">Profile Not Found</h1>
        <p class="error-msg">{errorMessage}</p>
        <a href="/" class="back-link">&larr; back to search</a>
      </div>
    </main>
  )}

  {profileData && !isComputing && !errorMessage && (
    <main class="profile-page">
      {/* Profile Header with badges and tag pills */}
      <ProfileHeader
        name={profileData.profile?.display_name || username}
        subtitle={subtitle}
        meta={meta}
        avatarUrl={profileData.profile?.avatar_url}
        badges={badges}
        languages={topLanguages}
        topics={topTopics}
      />

      {/* Radar Chart */}
      {radarAxes.length > 0 && (
        <RadarChart axes={radarAxes} size={320} />
      )}

      {/* Aggregate Charts (2x2 grid) */}
      {chartSections.length > 0 && (
        <section class="aggregates-section">
          <div class="aggregates-grid">
            {chartSections.map((s) => (
              <AggregateChart
                title={s.title}
                items={(aggByType[s.key] || []).map((a: any) => ({
                  name: a.item,
                  count: a.count,
                  color: s.key === "language" ? LANG_COLORS[a.item.toLowerCase()] : undefined,
                }))}
              />
            ))}
          </div>
        </section>
      )}

      {/* Star Interests */}
      {profileData.interests && profileData.interests.length > 0 && (
        <section class="interests-section">
          <div class="interests-grid">
            {profileData.interests.map((si: any) => {
              const label = si.label?.toLowerCase() || "";
              const isFeatured = featuredStarsSet.size > 0 && featuredStarsSet.has(label);
              return (
                <StarInterestTile
                  label={si.label}
                  count={si.count}
                  examples={si.examples}
                />
              );
            })}
          </div>
        </section>
      )}

      {/* Color Legend */}
      {profileData.personas && profileData.personas.length > 0 && (
        <ColorLegend
          personas={profileData.personas.map((p: any) => ({
            id: p.persona_id,
            title: (p.title || "").replace(/^(Principal|Staff|Crazy)\s+/, ""),
            accent: p.accent_color || PERSONA_COLORS[p.persona_id]?.accent || "#888",
          }))}
        />
      )}

      {/* Persona Cards Grid */}
      {profileData.personas && profileData.personas.length > 0 && (
        <section class="personas-section">
          <div class="persona-grid">
            {profileData.personas.map((p: any) => {
              const accent = p.accent_color || PERSONA_COLORS[p.persona_id]?.accent || "#888";
              const stats = (p.stats || []).map((s: any) =>
                Array.isArray(s) ? { label: s[0], value: s[1] } : s
              );
              return (
                <PersonaCard
                  id={p.persona_id}
                  title={p.title}
                  shortTitle={(p.title || "").replace(/^(Principal|Staff|Crazy)\s+/, "")}
                  tagline={p.tagline}
                  accent={accent}
                  icon={p.icon}
                  experience={p.experience_label}
                  yearsActive={p.years_active}
                  stats={stats}
                  stack={p.stack || []}
                  details={p.details || []}
                  employers={p.employers || []}
                />
              );
            })}
          </div>
        </section>
      )}

      {/* Featured Projects Section */}
      {displayProjects.length > 0 && (
        <section class="projects-section">
          <div class="section-header">
            <div class="section-label">Featured Projects</div>
            <h2 class="section-title">The Work</h2>
            <p class="section-sub">color-coded by persona affinity</p>
          </div>
          <div class="project-grid">
            {displayProjects.map((proj: any) => {
              const isFeatured = queryParams.featuredRepos.includes(proj.name?.toLowerCase());
              const isOrgFeatured = featuredOrgsSet.size > 0 && proj.url && featuredOrgsSet.has(
                new URL(proj.url).pathname.split("/")[1]?.toLowerCase()
              );
              return (
                <div class:list={["project-wrapper", { featured: isFeatured || isOrgFeatured }]}>
                  <ProjectCard
                    name={proj.name}
                    description={proj.description}
                    url={proj.url}
                    tech={proj.tech || []}
                    personaMap={proj.persona_map || []}
                    personas={personaRefs}
                  />
                </div>
              );
            })}
          </div>
        </section>
      )}

      {/* Persona Modals (hidden by default) */}
      {profileData.personas && profileData.personas.map((p: any) => {
        const accent = p.accent_color || PERSONA_COLORS[p.persona_id]?.accent || "#888";
        const stats = (p.stats || []).map((s: any) =>
          Array.isArray(s) ? { label: s[0], value: s[1] } : s
        );
        return (
          <PersonaModal
            id={p.persona_id}
            title={p.title}
            tagline={p.tagline}
            accent={accent}
            icon={p.icon}
            experience={p.experience_label}
            yearsActive={p.years_active}
            stats={stats}
            stack={p.stack || []}
            details={p.details || []}
            employers={p.employers || []}
            links={p.links || []}
          />
        );
      })}

      {/* Project Modals (hidden by default) */}
      {displayProjects.map((proj: any) => (
        <ProjectModal
          name={proj.name}
          description={proj.description}
          url={proj.url}
          tech={proj.tech || []}
          personaMap={proj.persona_map || []}
          personas={personaRefs}
          readmeExcerpt={proj.readme_excerpt}
        />
      ))}

      {/* Export */}
      <div class="export-bar">
        <span class="export-label">Export</span>
        <a href={`/${username}/export/json`} class="export-btn" download>JSON</a>
        <a href={`/${username}/export/md`} class="export-btn" download>Markdown</a>
        <a href={`/${username}/export/png`} class="export-btn" download>Image</a>
      </div>

      {/* Footer */}
      <footer class="profile-footer">
        <span>profiles.sh &middot; generated from public GitHub data</span>
      </footer>
    </main>
  )}
</Base>

<script>
  // Modal open: click on persona card "open details" button
  document.querySelectorAll('[data-persona-open]').forEach((btn) => {
    btn.addEventListener('click', () => {
      const id = (btn as HTMLElement).dataset.personaOpen;
      const modal = document.getElementById(`persona-modal-${id}`);
      if (modal) {
        modal.classList.add('active');
        document.body.style.overflow = 'hidden';
      }
    });
  });

  // Modal open: click on project card "open details" button
  document.querySelectorAll('[data-project-open]').forEach((btn) => {
    btn.addEventListener('click', () => {
      const name = (btn as HTMLElement).dataset.projectOpen;
      const modal = document.getElementById(`project-modal-${name}`);
      if (modal) {
        modal.classList.add('active');
        document.body.style.overflow = 'hidden';
      }
    });
  });

  // Modal close
  document.querySelectorAll('[data-modal-close]').forEach((btn) => {
    btn.addEventListener('click', () => {
      const overlay = (btn as HTMLElement).closest('.modal-overlay');
      if (overlay) {
        overlay.classList.remove('active');
        document.body.style.overflow = '';
      }
    });
  });

  // Close on backdrop click
  document.querySelectorAll('.modal-overlay').forEach((overlay) => {
    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) {
        overlay.classList.remove('active');
        document.body.style.overflow = '';
      }
    });
  });

  // Close on Escape key
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      document.querySelectorAll('.modal-overlay.active').forEach((overlay) => {
        overlay.classList.remove('active');
      });
      document.body.style.overflow = '';
    }
  });

  // Highlight featured topic pills from query params
  const url = new URL(window.location.href);
  const featuredTopics = (url.searchParams.get('featured-topics') || '')
    .split(',').map((s) => s.trim().toLowerCase()).filter(Boolean);
  if (featuredTopics.length > 0) {
    document.querySelectorAll('.pill-topic[data-topic]').forEach((pill) => {
      const topic = (pill as HTMLElement).dataset.topic || '';
      if (featuredTopics.includes(topic)) {
        pill.classList.add('featured');
      }
    });
  }
</script>

<style>
  .profile-page {
    max-width: 70rem;
    margin: 0 auto;
    padding: 48px 24px;
  }

  .error-page {
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    padding: 24px;
  }

  .error-content {
    text-align: center;
  }

  .label {
    font-size: 0.8125rem;
    font-family: "SF Mono", "Cascadia Code", "Fira Code", Consolas, monospace;
    letter-spacing: 4px;
    text-transform: uppercase;
    color: #444;
    margin-bottom: 16px;
  }

  .error-title {
    font-size: 1.75rem;
    font-weight: 200;
    color: #fff;
    margin: 0 0 12px;
  }

  .error-msg {
    font-size: 0.875rem;
    color: #888;
    font-family: "SF Mono", "Cascadia Code", "Fira Code", Consolas, monospace;
    margin: 0 0 24px;
  }

  .back-link {
    font-size: 0.8125rem;
    color: #666;
    font-family: "SF Mono", "Cascadia Code", "Fira Code", Consolas, monospace;
    text-decoration: underline;
    text-underline-offset: 2px;
  }

  .back-link:hover {
    color: #aaa;
  }

  .aggregates-section {
    max-width: 60rem;
    margin: 0 auto 40px;
  }

  .aggregates-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(20rem, 1fr));
    gap: 1rem;
  }

  .interests-section {
    max-width: 47.5rem;
    margin: 0 auto 40px;
  }

  .interests-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(12rem, 1fr));
    gap: 0.5rem;
  }

  .personas-section {
    margin: 0 auto 60px;
  }

  .persona-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(17rem, 1fr));
    gap: 0.75rem;
  }

  .projects-section {
    margin: 0 auto 48px;
  }

  .section-header {
    text-align: center;
    margin-bottom: 28px;
  }

  .section-label {
    font-size: 0.8125rem;
    font-family: "SF Mono", "Cascadia Code", "Fira Code", Consolas, monospace;
    color: #444;
    letter-spacing: 4px;
    text-transform: uppercase;
  }

  .section-title {
    margin: 8px 0 0;
    font-size: 1.75rem;
    font-weight: 200;
    color: #fff;
  }

  .section-sub {
    margin: 4px 0 0;
    font-size: 0.8125rem;
    color: #555;
    font-family: "SF Mono", "Cascadia Code", "Fira Code", Consolas, monospace;
  }

  .project-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(18rem, 1fr));
    gap: 1.125rem;
  }

  .project-wrapper.featured {
    border: 1px solid rgba(255, 200, 50, 0.3);
    border-radius: 8px;
    box-shadow: 0 0 12px rgba(255, 200, 50, 0.08);
  }

  .export-bar {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.5rem;
    margin-top: 48px;
  }

  .export-label {
    font-size: 0.8125rem;
    color: #444;
    font-family: "SF Mono", "Cascadia Code", "Fira Code", Consolas, monospace;
    letter-spacing: 2px;
    text-transform: uppercase;
  }

  .export-btn {
    font-size: 0.8125rem;
    font-family: "SF Mono", "Cascadia Code", "Fira Code", Consolas, monospace;
    color: #888;
    padding: 4px 10px;
    border-radius: 4px;
    border: 1px solid rgba(255, 255, 255, 0.08);
    background: rgba(255, 255, 255, 0.03);
    text-decoration: none;
    transition: background 0.15s, color 0.15s;
  }

  .export-btn:hover {
    background: rgba(255, 255, 255, 0.08);
    color: #ccc;
  }

  .profile-footer {
    text-align: center;
    margin-top: 48px;
    padding-bottom: 24px;
  }

  .profile-footer span {
    font-size: 0.8125rem;
    color: #333;
    font-family: "SF Mono", "Cascadia Code", "Fira Code", Consolas, monospace;
  }

  /* Responsive */
  @media (max-width: 768px) {
    .profile-page {
      padding: 24px 12px;
    }

    .persona-grid {
      gap: 6px;
    }

    .project-grid {
      gap: 12px;
    }
  }
</style>
